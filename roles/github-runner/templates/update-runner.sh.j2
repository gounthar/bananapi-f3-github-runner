#!/bin/bash
#
# Weekly update script for github-act-runner
# This script pulls the latest code, rebuilds the binary, and restarts the service
#
# Deployed by Ansible - do not edit manually
#

set -e

RUNNER_DIR="{{ runner_workdir }}"
SRC_DIR="${RUNNER_DIR}/src"
LOG_FILE="/var/log/github-runner-update.log"
LOCK_FILE="/tmp/github-runner-update.lock"
RUNNER_VERSION="{{ runner_version | default('main') }}"
GO_BUILD_FLAGS="{{ runner_build_flags | default('') }}"
WEBHOOK_URL="{{ runner_update_webhook | default('') }}"

# Logging function (writes only to file, cron handles stdout redirection)
log() {
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $*" >> "$LOG_FILE"
}

# Send webhook notification (for failures or updates)
send_notification() {
    local status="$1"
    local message="$2"

    if [ -n "$WEBHOOK_URL" ]; then
        local payload
        payload=$(cat <<PAYLOAD
{
    "status": "${status}",
    "runner": "{{ runner_name }}",
    "host": "$(hostname)",
    "message": "${message}",
    "timestamp": "$(date -Iseconds)"
}
PAYLOAD
)
        # Send webhook (fire and forget, don't fail on notification errors)
        curl -s -X POST -H "Content-Type: application/json" -d "$payload" "$WEBHOOK_URL" >/dev/null 2>&1 || true
        log "Notification sent: $status - $message"
    fi
}

# Validate runner_version format (branch name or tag)
validate_runner_version() {
    # Allow alphanumeric, hyphens, underscores, dots, and forward slashes (for refs like feature/foo)
    if ! echo "$RUNNER_VERSION" | grep -qE '^[a-zA-Z0-9._/-]+$'; then
        log "ERROR: Invalid runner_version format: $RUNNER_VERSION"
        send_notification "error" "Invalid runner_version format: $RUNNER_VERSION"
        exit 1
    fi

    # Prevent dangerous patterns
    if echo "$RUNNER_VERSION" | grep -qE '(^\.|\.\.|/\.|/$)'; then
        log "ERROR: runner_version contains potentially dangerous pattern: $RUNNER_VERSION"
        send_notification "error" "Invalid runner_version: $RUNNER_VERSION"
        exit 1
    fi
}

# Use flock for robust file-based locking
acquire_lock() {
    exec 200>"$LOCK_FILE"
    if ! flock -n 200; then
        log "ERROR: Another update is already running (could not acquire lock)"
        exit 1
    fi
    # Lock acquired, will be released when script exits
}

# Cleanup function
cleanup() {
    # flock is automatically released when fd 200 is closed (script exit)
    rm -f "$LOCK_FILE" 2>/dev/null || true
}

trap cleanup EXIT

# Validate runner_version before proceeding
validate_runner_version

# Acquire lock using flock
acquire_lock

log "Starting github-act-runner update check..."

# Verify source directory exists
if [ ! -d "$SRC_DIR" ]; then
    log "ERROR: Source directory $SRC_DIR does not exist"
    send_notification "error" "Source directory $SRC_DIR does not exist"
    exit 1
fi

cd "$SRC_DIR" || {
    log "ERROR: Cannot access source directory $SRC_DIR"
    send_notification "error" "Cannot access source directory $SRC_DIR"
    exit 1
}

# Get current commit (fail fast if repo is broken)
CURRENT_COMMIT=$(git rev-parse HEAD 2>/dev/null) || {
    log "ERROR: Unable to determine current commit (HEAD). Repository may be corrupted."
    send_notification "error" "Unable to determine current commit (HEAD)"
    exit 1
}
log "Current commit: $CURRENT_COMMIT"

# Fetch latest changes
log "Fetching latest changes from origin..."
if ! git fetch origin "$RUNNER_VERSION"; then
    log "ERROR: Failed to fetch from origin for version $RUNNER_VERSION"
    send_notification "error" "Failed to fetch from origin for version $RUNNER_VERSION"
    exit 1
fi

# Get remote commit (fail fast if branch doesn't exist)
REMOTE_COMMIT=$(git rev-parse "origin/$RUNNER_VERSION" 2>/dev/null) || {
    log "ERROR: Unable to determine remote commit for origin/$RUNNER_VERSION. Branch may not exist."
    send_notification "error" "Unable to determine remote commit for origin/$RUNNER_VERSION"
    exit 1
}
log "Remote commit: $REMOTE_COMMIT"

# Check if update is needed
if [ "$CURRENT_COMMIT" = "$REMOTE_COMMIT" ]; then
    log "Already up to date. No rebuild needed."
    exit 0
fi

log "New version available. Updating..."

# Pull latest changes (using checkout + reset for clean state)
git checkout "$RUNNER_VERSION"
git reset --hard "origin/$RUNNER_VERSION"

# Build new binary with configurable flags
log "Building new github-act-runner binary..."
BUILD_CMD="go build"
if [ -n "$GO_BUILD_FLAGS" ]; then
    BUILD_CMD="go build $GO_BUILD_FLAGS"
    log "Using build flags: $GO_BUILD_FLAGS"
fi

if ! $BUILD_CMD -o github-act-runner; then
    log "ERROR: Build failed"
    send_notification "error" "Build failed for commit $(git rev-parse HEAD)"
    exit 1
fi

# Verify binary exists and is executable
if [ ! -x github-act-runner ]; then
    log "ERROR: Built binary github-act-runner not found or not executable"
    send_notification "error" "Built binary not found or not executable"
    exit 1
fi

# Backup old binary before overwriting
log "Installing new binary..."
if [ -f "${RUNNER_DIR}/github-act-runner" ]; then
    cp "${RUNNER_DIR}/github-act-runner" "${RUNNER_DIR}/github-act-runner.backup"
fi
cp github-act-runner "${RUNNER_DIR}/"

# Restart the service
log "Restarting github-runner service..."
sudo /usr/bin/systemctl restart github-runner

# Wait for service to become active with polling (max 60 seconds)
MAX_WAIT_TIME=60
WAIT_INTERVAL=5
ELAPSED_TIME=0
while ! systemctl is-active --quiet github-runner && [ "$ELAPSED_TIME" -lt "$MAX_WAIT_TIME" ]; do
    log "Service not yet active, waiting..."
    sleep "$WAIT_INTERVAL"
    ELAPSED_TIME=$((ELAPSED_TIME + WAIT_INTERVAL))
done

if systemctl is-active --quiet github-runner; then
    NEW_COMMIT=$(git rev-parse HEAD)
    log "Update complete. Service is running."
    log "Updated from $CURRENT_COMMIT to $NEW_COMMIT"
    send_notification "success" "Updated from ${CURRENT_COMMIT:0:8} to ${NEW_COMMIT:0:8}"
else
    log "ERROR: Service failed to start after update!"
    # Attempt to restore backup
    if [ -f "${RUNNER_DIR}/github-act-runner.backup" ]; then
        log "Attempting to restore backup binary..."
        cp "${RUNNER_DIR}/github-act-runner.backup" "${RUNNER_DIR}/github-act-runner"
        sudo /usr/bin/systemctl restart github-runner
        sleep 5
        if systemctl is-active --quiet github-runner; then
            log "Backup restored successfully, service is running"
            send_notification "warning" "Update failed, rolled back to previous version"
        else
            send_notification "error" "Service failed to start after update and rollback failed"
        fi
    else
        send_notification "error" "Service failed to start after update, no backup available"
    fi
    exit 1
fi
