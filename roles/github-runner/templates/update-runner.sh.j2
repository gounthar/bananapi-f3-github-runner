#!/bin/bash
#
# Weekly update script for github-act-runner
# This script pulls the latest code, rebuilds the binary, and restarts the service
#
# Deployed by Ansible - do not edit manually
#

set -e

RUNNER_DIR="{{ runner_workdir }}"
SRC_DIR="${RUNNER_DIR}/src"
LOG_FILE="/var/log/github-runner-update.log"
LOCK_DIR="/tmp/github-runner-update.lock"

# Logging function (writes only to file, cron handles stdout redirection)
log() {
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $*" >> "$LOG_FILE"
}

# Create lock directory atomically (mkdir is atomic)
if ! mkdir "$LOCK_DIR" 2>/dev/null; then
    log "ERROR: Another update is already running (lock directory exists)"
    exit 1
fi

# Remove lock on exit
trap 'rmdir "$LOCK_DIR"' EXIT

log "Starting github-act-runner update check..."

# Verify source directory exists
if [ ! -d "$SRC_DIR" ]; then
    log "ERROR: Source directory $SRC_DIR does not exist"
    exit 1
fi

cd "$SRC_DIR" || { log "ERROR: Cannot access source directory $SRC_DIR"; exit 1; }

# Get current commit
CURRENT_COMMIT=$(git rev-parse HEAD 2>/dev/null || echo "unknown")
log "Current commit: $CURRENT_COMMIT"

# Fetch latest changes
log "Fetching latest changes from origin..."
if ! git fetch origin {{ runner_version | default('main') }}; then
    log "ERROR: Failed to fetch from origin"
    exit 1
fi

# Get remote commit
REMOTE_COMMIT=$(git rev-parse origin/{{ runner_version | default('main') }} 2>/dev/null || echo "unknown")
log "Remote commit: $REMOTE_COMMIT"

# Check if update is needed
if [ "$CURRENT_COMMIT" = "$REMOTE_COMMIT" ]; then
    log "Already up to date. No rebuild needed."
    exit 0
fi

log "New version available. Updating..."

# Pull latest changes (using checkout + reset for clean state)
if ! git checkout {{ runner_version | default('main') }}; then
    log "ERROR: Failed to checkout branch {{ runner_version | default('main') }}"
    exit 1
fi
if ! git reset --hard origin/{{ runner_version | default('main') }}; then
    log "ERROR: Failed to reset to origin/{{ runner_version | default('main') }}"
    exit 1
fi

# Build new binary with explicit error handling
log "Building new github-act-runner binary..."
if ! go build -o github-act-runner; then
    log "ERROR: Build failed"
    exit 1
fi

# Verify binary exists and is executable
if [ ! -x github-act-runner ]; then
    log "ERROR: Built binary github-act-runner not found or not executable"
    exit 1
fi

# Backup old binary before overwriting
log "Installing new binary..."
if [ -f "${RUNNER_DIR}/github-act-runner" ]; then
    cp "${RUNNER_DIR}/github-act-runner" "${RUNNER_DIR}/github-act-runner.backup"
fi
cp github-act-runner "${RUNNER_DIR}/"

# Restart the service
log "Restarting github-runner service..."
sudo systemctl restart github-runner

# Wait for service to become active with polling (max 60 seconds)
MAX_WAIT_TIME=60
WAIT_INTERVAL=5
ELAPSED_TIME=0
while ! systemctl is-active --quiet github-runner && [ "$ELAPSED_TIME" -lt "$MAX_WAIT_TIME" ]; do
    log "Service not yet active, waiting..."
    sleep "$WAIT_INTERVAL"
    ELAPSED_TIME=$((ELAPSED_TIME + WAIT_INTERVAL))
done

if systemctl is-active --quiet github-runner; then
    log "Update complete. Service is running."
    NEW_COMMIT=$(git rev-parse HEAD)
    log "Updated from $CURRENT_COMMIT to $NEW_COMMIT"
else
    log "ERROR: Service failed to start after update!"
    exit 1
fi
