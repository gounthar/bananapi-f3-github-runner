#!/bin/bash
#
# Weekly update script for github-act-runner
# This script pulls the latest code, rebuilds the binary, and restarts the service
#
# Deployed by Ansible - do not edit manually
#

set -e

RUNNER_DIR="{{ runner_workdir }}"
SRC_DIR="${RUNNER_DIR}/src"
LOG_FILE="/var/log/github-runner-update.log"
LOCK_DIR="/tmp/github-runner-update.lock"
HOSTNAME=$(hostname)

# Notification configuration
NOTIFY_ON_FAILURE="{{ runner_notify_on_failure | default(false) | lower }}"
NOTIFY_WEBHOOK_URL="{{ runner_notify_webhook_url | default('') }}"
NOTIFY_EMAIL="{{ runner_notify_email | default('') }}"

# Logging function (writes only to file, cron handles stdout redirection)
log() {
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $*" >> "$LOG_FILE"
}

# Escape special JSON characters in a string
json_escape() {
    local str="$1"
    # Escape backslashes, quotes, and control characters for JSON
    str="${str//\\/\\\\}"
    str="${str//\"/\\\"}"
    str="${str//$'\n'/\\n}"
    str="${str//$'\r'/\\r}"
    str="${str//$'\t'/\\t}"
    printf '%s' "$str"
}

# Send webhook notification
send_webhook() {
    local message="$1"
    if [ -n "$NOTIFY_WEBHOOK_URL" ]; then
        log "Sending webhook notification..."
        
        # Escape values for JSON
        local escaped_message
        local escaped_hostname
        local timestamp
        escaped_message=$(json_escape "$message")
        escaped_hostname=$(json_escape "$HOSTNAME")
        # Timestamp format is JSON-safe (only digits, hyphens, colons, and spaces)
        timestamp=$(date '+%Y-%m-%d %H:%M:%S')
        
        # JSON payload designed to be compatible with multiple webhook services:
        # - "text": Used by Slack and generic webhooks
        # - "content"/"embeds": Used by Discord
        # - "attachments": Used by Slack for rich formatting
        # Services will ignore fields they don't recognize
        local payload
        payload=$(cat <<EOF
{
    "text": "GitHub Runner Update Failed on ${escaped_hostname}",
    "content": "GitHub Runner Update Failed on ${escaped_hostname}",
    "embeds": [{"description": "${escaped_message}"}],
    "attachments": [{
        "color": "danger",
        "title": "GitHub Runner Update Failure",
        "text": "${escaped_message}",
        "fields": [
            {"title": "Host", "value": "${escaped_hostname}", "short": true},
            {"title": "Time", "value": "${timestamp}", "short": true}
        ]
    }]
}
EOF
)
        if curl -s -X POST -H "Content-Type: application/json" -d "$payload" "$NOTIFY_WEBHOOK_URL" >/dev/null 2>&1; then
            log "Webhook notification sent successfully"
        else
            log "WARNING: Failed to send webhook notification"
        fi
    fi
}

# Send email notification
send_email() {
    local message="$1"
    if [ -n "$NOTIFY_EMAIL" ]; then
        # Validate email format (basic check for @ symbol and no dangerous characters)
        if ! echo "$NOTIFY_EMAIL" | grep -qE '^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,}$'; then
            log "WARNING: Invalid email address format. Skipping email notification."
            return 1
        fi
        
        log "Sending email notification to ${NOTIFY_EMAIL}..."
        local subject="GitHub Runner Update Failed on ${HOSTNAME}"
        local timestamp
        timestamp=$(date '+%Y-%m-%d %H:%M:%S')
        local body="GitHub Runner Update Failure Report

Host: ${HOSTNAME}
Time: ${timestamp}

Error Details:
${message}

Please check the log file at ${LOG_FILE} for more details."

        if command -v mail >/dev/null 2>&1; then
            echo "$body" | mail -s "$subject" -- "$NOTIFY_EMAIL" 2>/dev/null && \
                log "Email notification sent successfully" || \
                log "WARNING: Failed to send email notification"
        elif command -v sendmail >/dev/null 2>&1; then
            {
                echo "To: ${NOTIFY_EMAIL}"
                echo "Subject: ${subject}"
                echo ""
                echo "$body"
            } | sendmail -t 2>/dev/null && \
                log "Email notification sent successfully" || \
                log "WARNING: Failed to send email notification"
        else
            log "WARNING: No mail command available (mail or sendmail). Cannot send email notification."
        fi
    fi
}

# Send failure notification via configured channels
notify_failure() {
    local message="$1"
    if [ "$NOTIFY_ON_FAILURE" = "true" ]; then
        send_webhook "$message"
        send_email "$message"
    fi
}

# Create lock directory atomically (mkdir is atomic)
if ! mkdir "$LOCK_DIR" 2>/dev/null; then
    log "ERROR: Another update is already running (lock directory exists)"
    notify_failure "Another update is already running (lock directory exists)"
    exit 1
fi

# Remove lock on exit
trap 'rmdir "$LOCK_DIR"' EXIT

log "Starting github-act-runner update check..."

# Verify source directory exists
if [ ! -d "$SRC_DIR" ]; then
    log "ERROR: Source directory $SRC_DIR does not exist"
    notify_failure "Source directory $SRC_DIR does not exist"
    exit 1
fi

cd "$SRC_DIR" || { log "ERROR: Cannot access source directory $SRC_DIR"; notify_failure "Cannot access source directory $SRC_DIR"; exit 1; }

# Get current commit
CURRENT_COMMIT=$(git rev-parse HEAD 2>/dev/null || echo "unknown")
log "Current commit: $CURRENT_COMMIT"

# Fetch latest changes
log "Fetching latest changes from origin..."
if ! git fetch origin {{ runner_version | default('main') }}; then
    log "ERROR: Failed to fetch from origin"
    notify_failure "Failed to fetch from origin (git fetch failed)"
    exit 1
fi

# Get remote commit
REMOTE_COMMIT=$(git rev-parse origin/{{ runner_version | default('main') }} 2>/dev/null || echo "unknown")
log "Remote commit: $REMOTE_COMMIT"

# Check if update is needed
if [ "$CURRENT_COMMIT" = "$REMOTE_COMMIT" ]; then
    log "Already up to date. No rebuild needed."
    exit 0
fi

log "New version available. Updating..."

# Pull latest changes (using checkout + reset for clean state)
git checkout {{ runner_version | default('main') }}
git reset --hard origin/{{ runner_version | default('main') }}

# Build new binary with explicit error handling
log "Building new github-act-runner binary..."
if ! go build -o github-act-runner; then
    log "ERROR: Build failed"
    notify_failure "Build failed (go build command failed)"
    exit 1
fi

# Verify binary exists and is executable
if [ ! -x github-act-runner ]; then
    log "ERROR: Built binary github-act-runner not found or not executable"
    notify_failure "Built binary github-act-runner not found or not executable"
    exit 1
fi

# Backup old binary before overwriting
log "Installing new binary..."
if [ -f "${RUNNER_DIR}/github-act-runner" ]; then
    cp "${RUNNER_DIR}/github-act-runner" "${RUNNER_DIR}/github-act-runner.backup"
fi
cp github-act-runner "${RUNNER_DIR}/"

# Restart the service
log "Restarting github-runner service..."
sudo systemctl restart github-runner

# Wait for service to become active with polling (max 60 seconds)
MAX_WAIT_TIME=60
WAIT_INTERVAL=5
ELAPSED_TIME=0
while ! systemctl is-active --quiet github-runner && [ "$ELAPSED_TIME" -lt "$MAX_WAIT_TIME" ]; do
    log "Service not yet active, waiting..."
    sleep "$WAIT_INTERVAL"
    ELAPSED_TIME=$((ELAPSED_TIME + WAIT_INTERVAL))
done

if systemctl is-active --quiet github-runner; then
    log "Update complete. Service is running."
    NEW_COMMIT=$(git rev-parse HEAD)
    log "Updated from $CURRENT_COMMIT to $NEW_COMMIT"
else
    log "ERROR: Service failed to start after update!"
    # Capture service status before passing to notification function
    service_status=$(systemctl status github-runner --no-pager 2>&1 | head -5)
    notify_failure "Service failed to start after update. Status: ${service_status}"
    exit 1
fi
